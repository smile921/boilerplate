# 收集一些质量较高的资料

## 前端精选资料

### InterviewMap/InterviewMap

[InterviewMap](https://yuchengkai.cn/docs/) [InterviewMap 中文](https://yuchengkai.cn/docs/zh/) 这是一份能让你更好准备下一次面试的图谱
本图谱目前包含了近百个高频知识点，无论是面试前的准备还是平时学习中的查漏补缺，我们相信肯定能帮助到大家。目前内容包含了 JS、网络、浏览器相关、性能优化、安全、框架、Git、数据结构、算法等内容，无论是基础还是进阶，亦或是源码解读，你都能在本图谱中得到满意的答案，希望这个面试图谱能够帮助到大家更好的准备面试。

### fejes713/30-seconds-of-interviews

[30-seconds-of-interviews](https://30secondsofinterviews.org/) 一些精挑细选的简短面试题，能让你更好的准备下次面试，主要包含 Javascript, HTML, CSS, Node, Security 等

### atomiks/30-seconds-of-css
[atomiks/30-seconds-of-css](https://github.com/atomiks/30-seconds-of-css)

### yygmind/Reading-Notes

[yygmind/Reading-Notes 你不知道的JavaScript上卷](https://github.com/yygmind/Reading-Notes/blob/master/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JavaScript%E4%B8%8A%E5%8D%B7.md)
日常读书，日常记笔记，一步一脚印，一岁一枯荣

### qiu-deqing/FE-interview
[qiu-deqing/FE-interview](https://github.com/qiu-deqing/FE-interview) 收集前端面试题目和答案

### JavaScript 算法实现
[trekhleb/javascript-algorithms](https://github.com/trekhleb/javascript-algorithms) 经典算法基于JavaScript的实现

### css-doodle/css-doodle

[css-doodle/css-doodle](https://css-doodle.com) 纯CSS的绘画组建

### TypeScript 入门教程
[https://github.com/xcatliu/typescript-tutorial](https://github.com/xcatliu/typescript-tutorial)

### USPTO/designpatterns
[USPTO/designpatterns](https://github.com/USPTO/designpatterns)

## 后端 JAVA

### crossoverJie / Java-Interview

[crossoverJie / Java-Interview](https://github.com/crossoverJie/Java-Interview) java相关 基础，并发，算法等
多数是一些 Java 基础知识、底层原理、算法详解。也有上层应用设计，其中不乏一些大厂面试真题。集合	多线程	JVM	分布式	框架	架构设计	数据库	算法	Netty	附加技能

### CyC2018/Interview-Notebook

[CyC2018/Interview-Notebook](https://github.com/CyC2018/Interview-Notebook) 学习笔记，包含算法✏️	操作系统💻	网络☁️	面向对象👫	数据库💾	Java ☕️	系统设计💡	工具🔨	编码实践🙊	后记等等 主题

### Snailclimb/Java-Guide

[Snailclimb/Java-Guide](https://github.com/Snailclimb/Java-Guide) Java面试通关手册（Java学习指南）Java Interview Customs Manual (Java Study Guide) 该文档主要是笔主在学习Java的过程中的一些学习笔记，但是为了能够涉及到大部分后端学习所需的技术知识点我也会偶尔引用一些别人的优秀文章的链接。 该文档涉及的主要内容包括： Java、 数据结构与算法、计算机网络与数据通信、 操作系统、主流框架、数据存储、架构、面试必备知识点等等。相信不论你是前端还是后端都能在这份文档中收获到东西

### oldratlee/fucking-java-concurrency

### point_right 通过Demo演示出Java中并发问题。

*整理Demo的原因*
* 可以观察到的实际现象 see_no_evil 比 说说的并发原则 speak_no_evil 更直观更可信。
* Java语言标准库支持线程，语言本身（如GC）以及应用（服务器端The Server side）中会重度使用多线程。
* 并发程度设计在分析和实现中，复杂度大大增加。 如果不系统理解和充分分析并发逻辑，随意写代码，这样的程序用 『碰巧』 能运行出正确结果 来形容一点都不为过。
[一些并发的问题讨论和资料](https://github.com/oldratlee/fucking-java-concurrency#%E4%B8%80%E4%BA%9B%E5%B9%B6%E5%8F%91%E7%9A%84%E9%97%AE%E9%A2%98%E8%AE%A8%E8%AE%BA%E5%92%8C%E8%B5%84%E6%96%99)

[oldratlee/fucking-java-concurrency](https://github.com/oldratlee/fucking-java-concurrency) 通过Demo演示出Java中并发问题。

### xingshaocheng/architect-awesome 架构师图谱

[xingshaocheng/architect-awesome](https://github.com/xingshaocheng/architect-awesome)

### kamranahmedse/developer-roadmap
[kamranahmedse/developer-roadmap](https://github.com/kamranahmedse/developer-roadmap)

### donnemartin/system-design-primer
[donnemartin/system-design-primer](https://github.com/donnemartin/system-design-primer) 系统架构设计

### winterbe/java8-tutorial

[winterbe/java8-tutorial](https://github.com/winterbe/java8-tutorial)

### cxxr/better-java

[cxxr/better-java](https://github.com/cxxr/better-java)

### giantray/stackoverflow-java-top-qa

[giantray/stackoverflow-java-top-qa](https://github.com/giantray/stackoverflow-java-top-qa)

### akullpp/awesome-java
[akullpp/awesome-java](https://github.com/akullpp/awesome-java)
[Vedenin/useful-java-links](https://github.com/Vedenin/useful-java-links)

## Blog 精选

* [javadoop.com](https://javadoop.com/)
* [Java 进阶](https://crossoverjie.top/categories/Java-%E8%BF%9B%E9%98%B6/)
* [aooy/blog](https://github.com/aooy/blog)
* [creeperyang/blog](https://github.com/creeperyang/blog)
* [justjavac/justjavac.github.com]( http://justjavac.com)
* [torokmark / design_patterns_in_typescript](https://github.com/torokmark/design_patterns_in_typescript)
* [berwin/Blog](https://github.com/berwin/Blog)
* [RxJS-CN/rxjs-articles-translation](https://github.com/RxJS-CN/rxjs-articles-translation)
* [RxJS-CN/learn-rxjs-operators](https://github.com/RxJS-CN/learn-rxjs-operators)
* [seven1m / 30-days-of-elixir](https://github.com/seven1m/30-days-of-elixir)
* [程序员DD](http://blog.didispace.com)
* [纯洁的微笑](http://www.mooooc.com)


## 文章收集

[图片压缩优化--如何使用 Node 优化图片](https://freshman.tech/image-optimisation/#optimise-png-images-with-pngquant)
[AN INTEGER FORMULA FOR FIBONACCI NUMBERS](https://blog.paulhankin.net/fibonacci/)

### 何谓悲观锁与乐观锁

> 乐观锁对应于生活中乐观的人总是想着事情往好的方向发展，悲观锁对应于生活中悲观的人总是想着事情往坏的方向发展。这两种人各有优缺点，不能不以场景而定说一种人好于另外一种人。

#### 悲观锁

总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁（**共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程**）。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。Java中`synchronized`和`ReentrantLock`等独占锁就是悲观锁思想的实现。


#### 乐观锁

总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号机制和CAS算法实现。**乐观锁适用于多读的应用类型，这样可以提高吞吐量**，像数据库提供的类似于**write_condition机制**，其实都是提供的乐观锁。在Java中`java.util.concurrent.atomic`包下面的原子变量类就是使用了乐观锁的一种实现方式**CAS**实现的。

#### 两种锁的使用场景

从上面对两种锁的介绍，我们知道两种锁各有优缺点，不可认为一种好于另一种，像**乐观锁适用于写比较少的情况下（多读场景）**，即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。但如果是多写的情况，一般会经常产生冲突，这就会导致上层应用会不断的进行retry，这样反倒是降低了性能，所以**一般多写的场景下用悲观锁就比较合适。**


### 乐观锁常见的两种实现方式

> **乐观锁一般会使用版本号机制或CAS算法实现。**

#### 1. 版本号机制

一般是在数据表中加上一个数据版本号version字段，表示数据被修改的次数，当数据被修改时，version值会加一。当线程A要更新数据值时，在读取数据的同时也会读取version值，在提交更新时，若刚才读取到的version值为当前数据库中的version值相等时才更新，否则重试更新操作，直到更新成功。

**举一个简单的例子：**
假设数据库中帐户信息表中有一个 version 字段，当前值为 1 ；而当前帐户余额字段（ balance ）为 $100 。

1. 操作员 A 此时将其读出（ version=1 ），并从其帐户余额中扣除 $50（ $100-$50 ）。
2. 在操作员 A 操作的过程中，操作员B 也读入此用户信息（ version=1 ），并从其帐户余额中扣除 $20 （ $100-$20 ）。
3. 操作员 A 完成了修改工作，将数据版本号加一（ version=2 ），连同帐户扣除后余额（ balance=$50 ），提交至数据库更新，此时由于提交数据版本大于数据库记录当前版本，数据被更新，数据库记录 version 更新为 2 。
4. 操作员 B 完成了操作，也将版本号加一（ version=2 ）试图向数据库提交数据（ balance=$80 ），但此时比对数据库记录版本时发现，操作员 B 提交的数据版本号为 2 ，数据库记录当前版本也为 2 ，不满足 “ 提交版本必须大于记录当前版本才能执行更新 “ 的乐观锁策略，因此，操作员 B 的提交被驳回。

这样，就避免了操作员 B 用基于 version=1 的旧数据修改的结果覆盖操作员A 的操作结果的可能。

####  2. CAS算法

即**compare and swap（比较与交换）**，是一种有名的**无锁算法**。无锁编程，即不使用锁的情况下实现多线程之间的变量同步，也就是在没有线程被阻塞的情况下实现变量的同步，所以也叫非阻塞同步（Non-blocking Synchronization）。**CAS算法**涉及到三个操作数

- 需要读写的内存值 V
- 进行比较的值 A
- 拟写入的新值 B

当且仅当 V 的值等于 A时，CAS通过原子方式用新值B来更新V的值，否则不会执行任何操作（比较和替换是一个原子操作）。一般情况下是一个**自旋操作**，即**不断的重试**。

关于自旋锁，大家可以看一下这篇文章，非常不错：[《
面试必备之深入理解自旋锁》](https://blog.csdn.net/qq_34337272/article/details/81252853)

### 乐观锁的缺点

>  ABA 问题是乐观锁一个常见的问题

#### 1 ABA 问题

如果一个变量V初次读取的时候是A值，并且在准备赋值的时候检查到它仍然是A值，那我们就能说明它的值没有被其他线程修改过了吗？很明显是不能的，因为在这段时间它的值可能被改为其他值，然后又改回A，那CAS操作就会误认为它从来没有被修改过。这个问题被称为CAS操作的 **"ABA"问题。**

JDK 1.5 以后的 `AtomicStampedReference 类`就提供了此种能力，其中的 `compareAndSet 方法`就是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。

#### 2 循环时间长开销大
**自旋CAS（也就是不成功就一直循环执行直到成功）如果长时间不成功，会给CPU带来非常大的执行开销。** 如果JVM能支持处理器提供的pause指令那么效率会有一定的提升，pause指令有两个作用，第一它可以延迟流水线执行指令（de-pipeline）,使CPU不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零。第二它可以避免在退出循环的时候因内存顺序冲突（memory order violation）而引起CPU流水线被清空（CPU pipeline flush），从而提高CPU的执行效率。

#### 3 只能保证一个共享变量的原子操作

CAS 只对单个共享变量有效，当操作涉及跨多个共享变量时 CAS 无效。但是从 JDK 1.5开始，提供了`AtomicReference类`来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行 CAS 操作.所以我们可以使用锁或者利用`AtomicReference类`把多个共享变量合并成一个共享变量来操作。



### CAS与synchronized的使用情景

> **简单的来说CAS适用于写比较少的情况下（多读场景，冲突一般较少），synchronized适用于写比较多的情况下（多写场景，冲突一般较多）**

1. 对于资源竞争较少（线程冲突较轻）的情况，使用synchronized同步锁进行线程阻塞和唤醒切换以及用户态内核态间的切换操作额外浪费消耗cpu资源；而CAS基于硬件实现，不需要进入内核，不需要切换线程，操作自旋几率较少，因此可以获得更高的性能。
2. 对于资源竞争严重（线程冲突严重）的情况，CAS自旋的概率会比较大，从而浪费更多的CPU资源，效率低于synchronized。


补充： Java并发编程这个领域中synchronized关键字一直都是元老级的角色，很久之前很多人都会称它为 **“重量级锁”** 。但是，在JavaSE 1.6之后进行了主要包括为了减少获得锁和释放锁带来的性能消耗而引入的 **偏向锁** 和 **轻量级锁** 以及其它**各种优化**之后变得在某些情况下并不是那么重了。synchronized的底层实现主要依靠 **Lock-Free** 的队列，基本思路是 **自旋后阻塞**，**竞争切换后继续竞争锁**，**稍微牺牲了公平性，但获得了高吞吐量**。在线程冲突较少的情况下，可以获得和CAS类似的性能；而线程冲突严重的情况下，性能远高于CAS。

#### CAS spinLock demo

````java

public class SpinLock {
    private AtomicReference<Thread> cas = new AtomicReference<Thread>();
    public void lock() {
        Thread current = Thread.currentThread();
        // 利用CAS
        while (!cas.compareAndSet(null, current)) {
            // DO nothing
        }
    }
    public void unlock() {
        Thread current = Thread.currentThread();
        cas.compareAndSet(current, null);
    }
}
````
> lock()方法利用的CAS，当第一个线程A获取锁的时候，能够成功获取到，不会进入while循环，如果此时线程A没有释放锁，另一个线程B又来获取锁，此时由于不满足CAS，所以就会进入while循环，不断判断是否满足CAS，直到A线程调用unlock方法释放了该锁
