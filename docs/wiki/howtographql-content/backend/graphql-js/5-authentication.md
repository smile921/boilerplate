---
title: 认证
pageTitle: "使用 Javascript 构建 GraphQL服务器之认证"
description: "了解使用 Javascript，Node.js 和 Express 在 GraphQL 服务器上实现电子邮件密码验证的最佳实践。"
question: GraphQL 服务器必须进行什么样的身份验证？
answers: ["用户名/密码验证", "令牌验证", "任何使用 'Authorization' 请求头部的验证", "
任何一种，对认证没有要求"]
correctAnswer: 3
---

### 创建用户

到目前为止，我们一直只使用 `Link` 类型，现在新建 `User` 的事后了，以便应用程序可以显示谁发布了某个链接以及投票的人。

我们将需要一些注册用户，因此从创建它们的变更开始。你已经知道这个过程了，但我们再重复一遍：

<Instruction>

**步骤一**： 和往常一样，首先更新模式以及定义新的类型和变更。

```graphql(path=".../hackernews-graphql-js/src/schema/index.js")
type Mutation {
    createLink(url: String!, description: String!): Link

    # Note that this mutation could receive the email and password directly
    # as arguments, with no problem. You're just using this "authProvider"
    # instead to mimic the signature generated by Graphcool, which will
    # make it easier to integrate this server implementation later with the 
    # code from the frontend tutorials.
    createUser(name: String!, authProvider: AuthProviderSignupData!): User
}

type User {
    id: ID!
    name: String!
    email: String
}

input AuthProviderSignupData {
    email: AUTH_PROVIDER_EMAIL
}

input AUTH_PROVIDER_EMAIL {
    email: String!
    password: String!
}
```

</Instruction>

<Instruction>

**步骤二**：创建一个新的 MongoDB 集合来存储用户实体。

```js{5-5}(path=".../hackernews-graphql-js/src/mongo-connector.js")
module.exports = async () => {
    const db = await MongoClient.connect(MONGO_URL);
    return {
        Links: db.collection('links'),
        Users: db.collection('users'),
    };
}
```

</Instruction>

<Instruction>

**步骤三**：为新的变更添加一个解析函数，使用 MongoDB 来存储数据。

```js(path=".../hackernews-graphql-js/src/schema/resolvers.js")
Mutation: {
    // Add this block right after the `createLink` mutation resolver.
    createUser: async (root, data, {mongo: {Users}}) => {
    // You need to convert the given arguments into the format for the
    // `User` type, grabbing email and password from the "authProvider".
    const newUser = {
        name: data.name,
        email: data.authProvider.email.email,
        password: data.authProvider.email.password,
    };
    const response = await Users.insert(newUser);
    return Object.assign({id: response.insertedIds[0]}, newUser);
    },
},
```

</Instruction>

<Instruction>

**步骤四**：重新启动服务器并使用变更创建一个新的测试用户。你应该看到这样的结果：

![](http://i.imgur.com/5sjrV28.png)

</Instruction>

### 登录变更

现在我们有用户来，如何使用 GraphQL 进行登录呢？当然是通过新的变更！突变不仅仅是获取数据更是当需要某个操作时客户端与服务器通信的一种方式。

首次通过 GraphQL 对用户进行登录时，将使用简单的电子邮件/密码登录方法，返回可用于后续请求进行身份验证的令牌。

> 请注意，这 **不应该是** 一个生产就绪的身份验证功能，但对于小功能的原型来说是可以的。在真正的应用程序中，您应该确保在传递密码之前对密码进行正确加密，并使用良好的令牌生成方法，例如 [JWT](https://jwt.io/)。

添加此变更的工作流程将与我们之前完成的工作非常相似：

<Instruction>

**步骤一**：添加新的变更定义来更新我们的模式。

```graphql(path=".../hackernews-graphql-js/src/schema/index.js")
type Mutation {
    signinUser(email: AUTH_PROVIDER_EMAIL): SigninPayload!
}

type SigninPayload {
    token: String
    user: User
}
```

</Instruction>

<Instruction>

**步骤二**：添加一个通过给定电子邮件获取用户的解析函数，验证密码并返回令牌。另外，请记住从 MongoDB 处理 `_id` 字段，就像对 `Link` 一样。

```js(path=".../hackernews-graphql-js/src/schema/resolvers.js")
Mutation: {
    // ...

    signinUser: async (root, data, {mongo: {Users}}) => {
        const user = await Users.findOne({email: data.email.email});
        if (data.email.password === user.password) {
          return {token: `token-${user.email}`, user};
        }
      },
    },

    User: {
      // Convert the "_id" field from MongoDB to "id" from the schema.
      id: root => root._id || root.id,
    },
```

</Instruction>

<Instruction>

**步骤三**：重新启动服务器，并尝试用以前注册的用户来使用新的 `signinUser` 变更：

![](http://i.imgur.com/VknQkQ5.png)

</Instruction>

### 认证请求

通过 `signinUser` 变更提供的令牌，应用程序可以通过 `Authorization` 请求头部进行后续请求进行身份验证。 GraphQL 服务器应该能够从每个请求的标题中获取内容，检测与它相关的用户，并将这些信息传递给解析函数。

如之前已经看过的那样，在解析函数之间共享数据的最佳方式是上下文对象。在每个请求中，您都需要该对象不同，因为每个请求可能来自不同的用户。幸运的是，`apollo-server-express` 也是允许的。

<Instruction>

只需将该调用更改为 `graphqlExpress` 即可接收一个函数而不是固定对象。

```js{1-1,6-13}(path=".../hackernews-graphql-js/src/index.js")
const {authenticate} = require('./authentication');

const start = async () => {
  // ...

  const buildOptions = async (req, res) => {
    const user = await authenticate(req, mongo.Users);
    return {
      context: {mongo, user}, // This context object is passed to all resolvers.
      schema,
    };
  };
  app.use('/graphql', bodyParser.json(), graphqlExpress(buildOptions));

  // ...
}
```

</Instruction>

这个 `authenticate` 函数将执行实际请求验证并返回当前验证的用户（如果有的话）。

<Instruction>

创建一个新文件 `src/authentication.js` ，具体内容如下：

```js(path=".../hackernews-graphql-js/src/authentication.js")
const HEADER_REGEX = /bearer token-(.*)$/;

/**
 * This is an extremely simple token. In real applications make
 * sure to use a better one, such as JWT (https://jwt.io/).
 */
module.exports.authenticate = async ({headers: {authorization}}, Users) => {
  const email = authorization && HEADER_REGEX.exec(authorization)[1];
  return email && await Users.findOne({email});
}
```

</Instruction>

生成令牌是如此简单。就像以前说过的那样，当建立一个真实世界的应用程序时，请确保检查各种不同的令牌，如JWT。

### 创建用户的链接

我们的服务器现在可以检测触发每个 GraphQL 请求的用户。这在许多情况下可能是有用的。例如，经过身份验证的用户应该恰好是发布使用 `createLink` 变更创建的链接的用户。我们现在可以为每个链接存储此信息。

只需要按下面的步骤:

<Instruction>

**步骤一**：更新模式中 `Link` 来包含用户的信息。

```graphql(path=".../hackernews-graphql-js/src/schema/index.js")
type Link {
    id: ID!
    url: String!
    description: String!
    postedBy: User
}
```

</Instruction>

<Instruction>

**步骤二**：更新 `createLink` 的解析函数来存储链接的同时也存储用户的信息。

```js(path=".../hackernews-graphql-js/src/schema/resolvers.js")
Mutation: {
    createLink: async (root, data, {mongo: {Links}, user}) => {
        const newLink = Object.assign({postedById: user && user._id}, data)
        const response = await Links.insert(newLink);
        return Object.assign({id: response.insertedIds[0]}, newLink);
    },
},
```

</Instruction>

<Instruction>

**步骤三**：为 `Link` 中的 `postedBy` 字段来添加解析函数用通过指定的 `postedById` 来从 MongoDB 中获取并返回正确的用户信息。相比于直接使用 `allLinks` 查询来获取所有的链接，然后遍历找到正确的一个的方法，这种方法更加简洁，而且自动适应可能还需要获取链接的任何其他查询。除此之外使用单独的解析函数的另一个优点是，除非 GraphQL 请求实际上要求 `postedBy` 字段，否则它甚至不会被触发，而不必执行任何额外的检查以避免获取无用的数据。所以单独的解析函数将是这样的：

```js(path=".../hackernews-graphql-js/src/schema/resolvers.js")
Link: {
    id: root => root._id || root.id,

    postedBy: async ({postedById}, data, {mongo: {Users}}) => {
        return await Users.findOne({_id: postedById});
    },
},
```

</Instruction>

完成！不幸的是，如果尝试重新启动服务器并创建新的链接，那么它们仍然会以匿名方式存储，如下所示：
![](http://i.imgur.com/iObKYMi.png)
这是因为 GraphiQL 构建的请求的 `Authorization` 请求头部中没有传递任何内容，因为它并不真正了解正在使用的身份验证方法。幸运的是，这也是可以配置的。

### 配置 GraphiQL 的请求头部

现在，我们将配置 GraphiQL，以便在每个请求的 `Authorization` 中传递用户的令牌令牌。
为此，请按照这些简单的步骤：

<Instruction>

**步骤一**：首先，选择先前创建的用户作为登录的用户，也可以为此创建一个新的用户。

![](http://i.imgur.com/dlfNseV.png)

</Instruction>

<Instruction>

**步骤二**：
调用 `signinUser` 变更来获取要与请求一起传递的令牌。

![](http://i.imgur.com/jl5kC9U.png)

</Instruction>

<Instruction>

**步骤三**：现在需要做的是为 `graphiqlExpress` 的调用设置一个名为 `passHeader` 的新选项，使用适当的 `Authorization` 请求头部。

```js{3-3}(path=".../hackernews-graphql-js/src/index.js")
app.use('/graphiql', graphiqlExpress({
    endpointURL: '/graphql',
    passHeader: `'Authorization': 'bearer token-foo@bar.com'`,
}));
```

</Instruction>

<Instruction>

**步骤四**：尝试重新启动服务器，刷新 GraphiQL 并立即创建一个新的链接。你应该看到 `postedBy` 将有你选择的用户的信息。

![](https://i.imgur.com/WAH9DKw.png)

</Instruction>
