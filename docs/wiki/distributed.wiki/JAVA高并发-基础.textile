1、进程与线程的区别，进程间如何通讯，线程间如何通讯？
进程是操作系统的资源调度实体，有自己的内存地址空间和运行环境； 
线程一般被称为轻量级的进程，线程和进程一样，也有自己的运行环境。
线程存在于进程之中——每个进程至少有一个线程。一个进程下的多个线程之间可以共享进程的资源，包括内存空间和打开的文件。

进程间通讯依靠IPC资源，例如管道（pipes）、套接字（sockets）等； 
线程间通讯依靠JVM提供的API，例如wait方法、notify方法和notifyAll方法，线程间还可以通过共享的主内存来进行值的传递。

2、Java线程的状态？
Java线程在某个时刻只能处于以下六个状态中的一个。 
– New（新创建），一个线程刚刚被创建出来，还没有开始运行的状态，更通俗点说：还没有调用start方法； 
– Runnable（可运行），可以在Java虚拟机中运行的状态；一个可运行的线程可能正在运行自己的代码也可能没有，这取决于操作系统提供的时间片； – Blocked（被阻塞），当一个线程试图获取一个内部的对象锁（不是java.util.concurrent库中的锁），而该锁此时正被其他线程持有，则该线程进入阻塞状态； 
– Waiting（等待），当线程等待另一个线程通知调度器一个条件时，它自己进入等待状态。
在调用Object.wait方法或Thread.join方法，或者是等待java.util.concurrent库中的Lock或Condition时，就会出现这种情况； 
– Timed waiting（计时等待），Object.wait、Thread.join、Lock.tryLock和Condition.await等方法有超时参数，还有Thread.sleep方法、LockSupport.parkNanos方法和LockSupport.parkUntil方法，这些方法会导致线程进入计时等待状态，如果超时或者出现通知，都会切换会可运行状态； 
– Terminated（被终止），因为run方法正常退出而死亡，或者因为没有捕获的异常终止了run方法而死亡。

3、进程间的通信方式？
# 管道( pipe )：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。
# 有名管道 (namedpipe) ： 有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。
# 信号量(semophore ) ： 信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。
# 消息队列( messagequeue ) ： 消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。
# 信号 (sinal ) ： 信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。
# 共享内存(shared memory ) ：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号两，配合使用，来实现进程间的同步和通信。
# 套接字(socket ) ： 套解口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同及其间的进程通信。

4、线程间的通信方式？
# 锁机制：包括互斥锁、条件变量、读写锁
   *互斥锁提供了以排他方式防止数据结构被并发修改的方法。
   *读写锁允许多个线程同时读共享数据，而对写操作是互斥的。
   *条件变量可以以原子的方式阻塞进程，直到某个特定条件为真为止。对条件的测试是在互斥锁的保护下进行的。条件变量始终与互斥锁一起使用。
# 信号量机制(Semaphore)：包括无名线程信号量和命名线程信号量
# 信号机制(Signal)：类似进程间的信号处理
    线程间的通信目的主要是用于线程同步，所以线程没有像进程通信中的用于数据交换的通信机制。

5、线程间通信常用的三种方法

6、线程间的通信——wait及notify方法？
wait()方法： wait()方法使得当前线程必须要等待，等到另外一个线程调用notify()或者notifyAll()方法。
当前的线程必须拥有当前对象的monitor，也即lock，就是锁。
要确保调用wait()方法的时候拥有锁，即，wait()方法的调用必须放在synchronized方法或synchronized块中。
一个小比较：
当线程调用了wait()方法时，它会释放掉对象的锁。
另一个会导致线程暂停的方法：Thread.sleep()，它会导致线程睡眠指定的毫秒数，但线程在睡眠的过程中是不会释放掉对象的锁的。


notify()方法
notify()方法会唤醒一个等待当前对象的锁的线程。
被唤醒的线程是不能被执行的，需要等到当前线程放弃这个对象的锁。
被唤醒的线程将和其他线程以通常的方式进行竞争，来获得对象的锁。也就是说，被唤醒的线程并没有什么优先权，也没有什么劣势，对象的下一个线程还是需要通过一般性的竞争。

7、join方法的使用
join方法的功能就是使异步执行的线程变成同步执行。
thread.Join把指定的线程加入到当前线程，可以将两个交替执行的线程合并为顺序执行的线程。比如在线程B中调用了线程A的Join()方法，直到线程A执行完毕后，才会继续执行线程B。
join底层是wait方法，所以它是会释放对象锁的，而sleep在同步的方法中是不释放对象锁的，只有同步方法执行完毕，其他线程才可以执行。

为什么要用join()方法？
在很多情况下，主线程生成并起动了子线程，如果子线程里要进行大量的耗时的运算，主线程往往将于子线程之前结束，但是如果主线程处理完其他的事务后，需要用到子线程的处理结果，也就是主线程需要等待子线程执行完成之后再结束，这个时候就要用到join()方法了。

8、Java Thread.yield？
Java线程中有一个Thread.yield( )方法，很多人翻译成线程让步。顾名思义，就是说当一个线程使用了这个方法之后，它就会把自己CPU执行的时间让掉，让自己或者其它的线程运行。

如果你觉得一个线程不是那么重要，或者优先级非常低，而且又害怕它会占用太多的CPU资源，那么可以在适当的时候调用Thread.yield()，给予其他重要线程更多的工作机会。

9、线程调度？
a、调整线程优先级：Java线程有优先级，优先级高的线程会获得较多的运行机会。
Java线程的优先级用整数表示，取值范围是1~10，Thread类有以下三个静态常量：
static int MAX_PRIORITY 线程可以具有的最高优先级，取值为10。
static int MIN_PRIORITY 线程可以具有的最低优先级，取值为1。
static int NORM_PRIORITY 分配给线程的默认优先级，取值为5。
 
Thread类的setPriority()和getPriority()方法分别用来设置和获取线程的优先级。
每个线程都有默认的优先级。主线程的默认优先级为Thread.NORM_PRIORITY。
线程的优先级有继承关系，比如A线程中创建了B线程，那么B将和A具有相同的优先级。

b、线程睡眠：Thread.sleep(long millis)方法，使线程转到阻塞状态。millis参数设定睡眠的时间，以毫秒为单位。当睡眠结束后，就转为就绪（Runnable）状态。sleep()平台移植性好。

c、线程等待：Object类中的wait()方法，导致当前的线程等待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 唤醒方法。这个两个唤醒方法也是Object类中的方法，行为等价于调用 wait(0) 一样。

d、线程让步：Thread.yield() 方法，暂停当前正在执行的线程对象，把执行机会让给相同或者更高优先级的线程。

e、线程加入：join()方法，等待其他线程终止。在当前线程中调用另一个线程的join()方法，则当前线程转入阻塞状态，直到另一个进程运行结束，当前线程再由阻塞转为就绪状态。

f、线程唤醒：Object类中的notify()方法，唤醒在此对象监视器上等待的单个线程。

10、synchronized与ThreadLocal的区别

synchronized关键字主要解决多线程共享数据同步问题。
ThreadLocal使用场合主要解决多线程中数据因并发产生不一致问题。

ThreadLocal和Synchonized都用于解决多线程并发访问。但是ThreadLocal与synchronized有本质的区别:
synchronized是利用锁的机制，使变量或代码块在某一时该只能被一个线程访问。
ThreadLocal为每一个线程都提供了变量的副本，使得每个线程在某一时间访问到的并不是同一个对象，这样就隔离了多个线程对数据的数据共享。而Synchronized却正好相反，它用于在多个线程间通信时能够获得数据共享。
Synchronized用于线程间的数据共享，而ThreadLocal则用于线程间的数据隔离。当然ThreadLocal并不能替代synchronized,它们处理不同的问题域。Synchronized用于实现同步机制，比ThreadLocal更加复杂。

概括起来说，对于多线程资源共享的问题，同步机制采用了“以时间换空间”的方式，而ThreadLocal采用了“以空间换时间”的方式。前者仅提供一份变量，让不同的线程排队访问，而后者为每一个线程都提供了一份变量，因此可以同时访问而互不影响。

11、比较synchronized和读写锁？
读写锁

我们对数据的操作无非两种：“读”和“写”，试想一个这样的情景，当十个线程同时读取某个数据时，这个操作应不应该加同步。答案是没必要的。只有以下两种情况需要加同步：

这十个线程对这个公共数据既有读又有写
这十个线程对公共数据进行写操作
以上两点归结起来就一点就是有对数据进行改变的操作就需要同步
所以
java提供了读写锁这种锁支持多线程读操作不互斥，多线程读写互斥，多线程写写互斥。读操作不互斥这样有助于性能的提高。
12、无锁数据库 无锁并发、无锁并发编程、java 无锁并发、无锁并发框架、并发无锁队列

13、java内存模型

14、volatile?
