1、分布式与集群的联系和区别？
a:分布式是指将不同的业务分布到不同的地方。
b:集群是指将几台服务器集中在一起，实现同一个业务。
c:分布式的每一个节点，都可以用来做集群。而集群不一定就是分布式了。

2、分布式系统的优点?
a:模块拆分,使用接口通信,降低模块之间的耦合度.
b:把项目拆分成若干个子项目,不同的团队负责不同的子项目.
c:增加功能时只需要再增加一个子项目,调用其他系统的接口就可以。
d:可以灵活的进行分布式部署。　　
e:提高代码的复用性。

3、分布式系统的缺点?
a:系统之间的交互要使用远程通信,接口开发增大工作量
b:处理分布式存储、分布式事物、分布式锁相对复杂.

4、使用分布式的场景？

5、如何判断一个应用是否支持分布式？

7、解决java集群的session共享的解决方案？

a: 客户端cookie加密。
（一般用于内网中企业级的系统中，要求用户浏览器端的cookie不能禁用，禁用的话，该方案会失效）。

b: 集群中，各个应用服务器提供了session复制的功能，tomcat和jboss都实现了这样的功能。
特点：性能随着服务器增加急剧下降，容易引起广播风暴；session数据需要序列化，影响性能。

c: session的持久化，使用数据库来保存session。
就算服务器宕机也没事儿，数据库中的session照样存在。特点：每次请求session都要读写数据库，会带来性能开销。使用内存数据库，会提高性能，但是宕机会丢失数据(像支付宝的宕机，有同城灾备、异地灾备)。

D: 使用共享存储来保存session。
和数据库类似，就算宕机了也没有事。其实就是专门搞一台服务器，全部对session落地。特点：频繁的进行序列化和反序列化会影响性能。

E:使用memcached来保存session。
本质上是内存数据库的解决方案。特点：存入memcached的数据需要序列化，效率极低。

8:CAP理解?

Consistency：
强一致性就是在客户端任何时候看到各节点的数据都是一致的

Availability：
高可用性就是在任何时候都可以读写

Partition Tolerance：
分区容错性是在网络故障、某些节点不能通信的时候系统仍能继续工作以实际效果而言，分区相当于对通信的时限要求。系统如果不能在时限内达成数据一致性，就意味着发生了分区的情况，必须就当前操作在C和A之间做出选择。

9: ACID理解？

Atomicity 原子性：
一个事务中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚到事务开始前的状态，就像这个事务从来没有执行过一样。

Consistency 一致性：
在事务开始之前和事务结束以后，数据库的完整性没有被破坏。

Isolation 隔离性：
数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。

Durability 持久性：
事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。

10：分布式数据一致性理解？
强一致性：
当更新操作完成之后，任何多个后续进程或者线程的访问都会返回最新的更新过的值。这种是对用户最友好的，就是用户上一次写什么，下一次就保证能读到什么。根据 CAP 理论，这种实现需要牺牲可用性。

弱一致性：
系统并不保证后续进程或者线程的访问都会返回最新的更新过的值。系统在数据写入成功之后，不承诺立即可以读到最新写入的值，也不会具体的承诺多久之后可以读到。

最终一致性：
弱一致性的特定形式。系统保证在没有后续更新的前提下，系统最终返回上一次更新操作的值。在没有故障发生的前提下，不一致窗口的时间主要受通信延迟，系统负载和复制副本的个数影响。DNS 是一个典型的最终一致性系统。

11、分布式事务-本地消息表？
实现方式的思路是源于ebay，其基本的设计思想是将远程分布式事务拆分成一系列的本地事务。
跨行转账的例子来描述。
第一步伪代码如下，扣款1W，通过本地事务保证了凭证消息插入到消息表中。
Begin transaction
Update A set amount = amount - 10000 where userId = 1;
insert into message(userId, price, status) values(1, 10000, 1);
End transaction
commit;
第二步，通知对方银行账户上加1W了，通常采用两种方式：
	采用时效性高的MQ，由对方订阅消息并监听，有消息时自动触发事件。
	采用定时轮询扫描的方式，去检查消息表的数据。

12、分布式事务-非事务性的消息中间件？
Try {
   Bool result = dao.update(model);//操作数据库失败，会抛出异常
   if(result){
      mq.send(model); // 如果mq方式执行失败，会抛出异常
   }
} catch(Exception e) {
   rollback();//如果发生异常，则回滚
}

我们来分析下可能的情况：
a: 操作数据库成功，向MQ中投递消息也成功，皆大欢喜。
b: 操作数据库失败，不会向MQ中投递消息了。
c: 操作数据库成功，但是向MQ中投递消息时失败，向外抛出了异常，刚刚执行的更新数据库的操作将被回滚。
从上面分析的几种情况来看，基本上能保证发送者发送消息的可靠性。我们再来分析下消费者端面临的问题：
a: 消息出列后，消费者对应的业务操作要执行成功。如果业务执行失败，消息不能失效或者丢失。需要保证消息与业务操作一致。
b: 尽量避免消息重复消费。如果重复消费，也不能因此影响业务结果。

13、分布式事务-支持事务的消息中间件？
除了上面介绍的通过异常捕获和回滚的方式外，其他的思路
阿里巴巴的RocketMQ中间件就支持一种事务消息机制，能够确保本地操作和发送消息达到本地事务一样的效果。
第一阶段，RocketMQ在执行本地事务之前，会先发送一个Prepared消息，并且会持有这个消息的地址。
第二阶段，执行本地事物操作。
第三阶段，确认消息发送，通过第一阶段拿到的地址去访问消息，并修改状态，如果本地事务成功，则修改状态为已提交，否则修改状态为已回滚。

但是如果第三阶段的确认消息发送失败了怎么办？RocketMQ会定期扫描消息集群中的事物消息，如果发现了prepare状态的消息，它会向消息发送者确认本地事务是否已执行成功，如果成功是回滚还是继续发送确认消息呢。RocketMQ会根据发送端设置的策略来决定是回滚还是继续发送确认消息。这样就保证了消息发送与本地事务同时成功或同时失败。
目前主流的开源MQ（ActiveMQ、RabbitMQ、Kafka）均未实现对事务消息的支持，比较遗憾的是，RocketMQ事务消息部分的代码也并未开源，需要自己去实现。

14、理解2PC和3PC协议？
为了解决分布式一致性问题，前人在性能和数据一致性的反反复复权衡过程中总结了许多典型的协议和算法。其中比较著名的有二阶提交协议（2 Phase Commitment Protocol），三阶提交协议（3 Phase Commitment Protocol）。

15、2pc的过程?
二阶段提交的算法思路可以概括为：参与者将操作成败通知协调者，再由协调者根据所有参与者的反馈情报决定各参与者是否要提交操作还是中止操作。
所谓的两个阶段是指：第一阶段：准备阶段（投票阶段）和第二阶段：提交阶段（执行阶段）。

详细说明：
第一阶段：投票阶段
该阶段的主要目的在于打探数据库集群中的各个参与者是否能够正常的执行事务，具体步骤如下：
1. 协调者向所有的参与者发送事务执行请求，并等待参与者反馈事务执行结果。
2. 事务参与者收到请求之后，执行事务，但不提交，并记录事务日志。
3. 参与者将自己事务执行情况反馈给协调者，同时阻塞等待协调者的后续指令。
第二阶段：事务提交阶段
在第一阶段协调者的询盘之后，各个参与者会回复自己事务的执行情况，这时候存在三种可能：
1. 所有的参与者回复能够正常执行事务。
2. 一个或多个参与者回复事务执行失败。
3. 协调者等待超时。
对于第二、三种情况，协调者均认为参与者无法正常成功执行事务，为了整个集群数据的一致性，所以要向各个参与者发送事务回滚通知。

16、2pc的缺点？
两阶段提交协议解决的是分布式数据库数据强一致性问题，其原理简单，易于实现，但是缺点也是显而易见的，主要缺点如下：

单点问题：协调者在整个两阶段提交过程中扮演着举足轻重的作用，一旦协调者所在服务器宕机，那么就会影响整个数据库集群的正常运行，比如在第二阶段中，如果协调者因为故障不能正常发送事务提交或回滚通知，那么参与者们将一直处于阻塞状态，整个数据库集群将无法提供服务。

同步阻塞：两阶段提交执行过程中，所有的参与者都需要听从协调者的统一调度，期间处于阻塞状态而不能从事其他操作，这样效率及其低下。

数据不一致性：两阶段提交协议虽然为分布式数据强一致性所设计，但仍然存在数据不一致性的可能，比如在第二阶段中，假设协调者发出了事务commit的通知，但是因为网络问题该通知仅被一部分参与者所收到并执行了commit操作，其余的参与者则因为没有收到通知一直处于阻塞状态，这时候就产生了数据的不一致性。

17、3PC过程?
针对两阶段提交存在的问题，三阶段提交协议通过引入一个“预询盘”阶段，以及超时策略来减少整个集群的阻塞时间，提升系统性能。三阶段提交的三个阶段分别为：can_commit，pre_commit，do_commit。

第一阶段：can_commit
该阶段协调者会去询问各个参与者是否能够正常执行事务，参与者根据自身情况回复一个预估值，相对于真正的执行事务，这个过程是轻量的，具体步骤如下：
1. 协调者向各个参与者发送事务询问通知，询问是否可以执行事务操作，并等待回复。
2. 各个参与者依据自身状况回复一个预估值，如果预估自己能够正常执行事务就返回确定信息，并进入预备状态，否则返回否定信息。
第二阶段：pre_commit
本阶段协调者会根据第一阶段的询盘结果采取相应操作，询盘结果主要有三种：
1. 所有的参与者都返回确定信息。
2. 一个或多个参与者返回否定信息。
3. 协调者等待超时。
针对第一种情况，协调者会向所有参与者发送事务执行请求，具体步骤如下：
1. 协调者向所有的事务参与者发送事务执行通知。
2. 参与者收到通知后，执行事务，但不提交。
3. 参与者将事务执行情况返回给客户端。
在上面的步骤中，如果参与者等待超时，则会中断事务。 针对第二、三种情况，协调者认为事务无法正常执行，于是向各个参与者发出abort通知，请求退出预备状态，具体步骤如下：
1. 协调者向所有事务参与者发送abort通知
2. 参与者收到通知后，中断事务
第三阶段：do_commit
如果第二阶段事务未中断，那么本阶段协调者将会依据事务执行返回的结果来决定提交或回滚事务，分为三种情况：
1. 所有的参与者都能正常执行事务。
2. 一个或多个参与者执行事务失败。
3. 协调者等待超时。
针对第一种情况，协调者向各个参与者发起事务提交请求，具体步骤如下：
1. 协调者向所有参与者发送事务commit通知。
2. 所有参与者在收到通知之后执行commit操作，并释放占有的资源。
3. 参与者向协调者反馈事务提交结果。
针对第二、三种情况，协调者认为事务无法正常执行，于是向各个参与者发送事务回滚请求，具体步骤如下：
1. 协调者向所有参与者发送事务rollback通知。
2. 所有参与者在收到通知之后执行rollback操作，并释放占有的资源。
3. 参与者向协调者反馈事务提交结果。

17、3pc的缺点？
在本阶段如果因为协调者或网络问题，导致参与者迟迟不能收到来自协调者的commit或rollback请求，那么参与者将不会如两阶段提交中那样陷入阻塞，而是等待超时后继续commit。相对于两阶段提交虽然降低了同步阻塞，但仍然无法避免数据的不一致性。

18、何为分布式锁？
分布式锁是控制分布式系统之间同步访问共享资源的一种方式。在分布式系统中，常常需要协调他们的动作。如果不同的系统或是同一个系统的不同主机之间共享了一个或一组资源，那么访问这些资源的时候，往往需要互斥来防止彼此干扰来保证一致性，在这种情况下，便需要使用到分布式锁。

使用场景：秒杀等，使用工具:如redis，因为其一些特性，是实现分布式锁的重要工具。

19、Redis分布式锁常用操作？
redis的基本命令：

SETNX key value 
如果key不存在，就设置key对应字符串value。在这种情况下，该命令和SET一样。当key已经存在时，就不做任何操作。SETNX是”SET if Not eXists”。 

expire KEY seconds 
设置key的过期时间。如果key已过期，将会被自动删除。
 
del KEY 
删除key 

20、redis分布式锁的实现方式？

1、用什么操作redis？幸亏redis已经提供了jedis客户端用于java应用程序，直接调用jedis API即可。 
2、怎么实现加锁？“锁”其实是一个抽象的概念，将这个抽象概念变为具体的东西，就是一个存储在redis里的key-value对，key是于商品ID相关的字符串来唯一标识，value其实并不重要，因为只要这个唯一的key-value存在，就表示这个商品已经上锁。 
3、如何释放锁？既然key-value对存在就表示上锁，那么释放锁就自然是在redis里删除key-value对。 
4、阻塞还是非阻塞？笔者采用了阻塞式的实现，若线程发现已经上锁，会在特定时间内轮询锁。 
5、如何处理异常情况？比如一个线程把一个商品上了锁，但是由于各种原因，没有完成操作（就是没有将库存-1写入数据库），自然没有释放锁，这个情况加入了锁超时机制，利用redis的expire命令为key设置超时时长，过了超时时间redis就会将这个key自动删除，即强制释放锁（可以认为超时释放锁是一个异步操作，由redis完成，应用程序只需要根据系统特点设置超时时间即可）。

21、分布式缓存Memcache与Redis的比较？
（1）数据结构：Memcache只支持key value存储方式，Redis支持更多的数据类型，比如Key value，hash，list，set，zset；
（2）多线程：Memcache支持多线程，redis支持单线程；CPU利用方面Memcache优于redis；
（3）持久化：Memcache不支持持久化，Redis支持持久化；
（4）内存利用率：memcache高，redis低（采用压缩的情况下比memcache高）；
（5）过期策略：memcache过期后，不删除缓存，会导致下次取数据数据的问题，Redis有专门线程，清除缓存数据；



